<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Pico USB Serial ↔ I²C Bridge</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --pad: 12px; }
    body { font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; max-width: 920px; margin: 24px auto; padding: 0 12px; }
    h1 { font-size: 20px; margin: 0 0 8px; }
    .row { display: flex; flex-wrap: wrap; gap: 8px; margin: 8px 0; align-items: center; }
    button { padding: 8px 12px; border-radius: 10px; border: 1px solid #ccc; background: #fff; cursor: pointer; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    input, textarea { font: inherit; }
    input[type="number"] { width: 120px; }
    textarea { width: 100%; height: 260px; }
    fieldset { border: 1px solid #ddd; border-radius: 12px; padding: var(--pad); margin: 12px 0; }
    legend { padding: 0 6px; }
    .status { margin-left: 8px; font-weight: 600; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }


      /* Side-by-side layout for I²C + Upload blocks */
      .split {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
        align-items: start;
      }
      @media (max-width: 800px) {
        .split { grid-template-columns: 1fr; }
      }


  </style>
</head>
<body>
  <h1>Pico USB Serial ↔ I²C Bridge</h1>

  <div class="row">
    <button id="connect">Connect</button>
    <button id="disconnect" disabled>Disconnect</button>
    <span id="status" class="status">Not connected</span>
  </div>

  <div class="split">


  <fieldset>
    <legend>I²C helpers</legend>
    <div class="row">
      <label>Addr (7-bit dec): <input id="addr" type="number" min="0" max="127" value="72"></label>
      <label>Reg (dec): <input id="reg" type="number" min="0" max="255" value="0"></label>
    </div>
    <div class="row">
      <input id="dataHex" class="mono" style="flex:1" placeholder="Data bytes hex (e.g. 01 02 0A FF)">
    </div>
    <div class="row">
      <button id="btnWrite" disabled>i2c_write</button>
      <label>Read length: <input id="readLen" type="number" min="1" max="256" value="4"></label>
      <button id="btnRead" disabled>i2c_read</button>
    </div>
  </fieldset>

  <fieldset>
    <legend>Upload & Flash</legend>
    <div class="row">
      <input id="file" type="file" />
      <label>Chunk bytes: <input id="chunkSize" type="number" min="128" max="8192" value="1024"></label>
      <label><input id="verifySha" type="checkbox" checked> Verify SHA-256</label>
      <label><input id="autoFlash" type="checkbox" checked> Auto-flash after upload</label>
    </div>
    <div class="row">
      <button id="btnUpload" disabled>Upload & Flash</button>
      <span id="uStatus" class="muted"></span>
    </div>
    <progress id="prog" max="1" value="0"></progress>
  </fieldset>
  </div>

  <fieldset>
    <legend>Incoming (JSON lines from Pico)</legend>
    <textarea id="log" class="mono" readonly></textarea>
    <div class="row">
      <button id="clearLog">Clear log</button>
      <label><input id="autoscroll" type="checkbox" checked> Autoscroll</label>
    </div>
  </fieldset>

  <fieldset>
    <legend>Send raw JSON</legend>
    <div class="row">
      <input id="raw" class="mono" style="flex:1" placeholder='e.g. {"op":"ping"}'>
      <button id="sendRaw" disabled>Send</button>
    </div>
  </fieldset>



  
  <script>
    let port, reader, writer;
    let readAbort = null;

    const $ = id => document.getElementById(id);
    const autoscroll = () => $("autoscroll").checked;

    const log = (line) => {
      const el = $("log");
      el.value += (typeof line === "string" ? line : JSON.stringify(line)) + "\n";
      if (autoscroll()) el.scrollTop = el.scrollHeight;
    };

    async function openPort() {
      if (!("serial" in navigator)) {
        alert("Web Serial not available. Use a Chromium browser over HTTPS or localhost.");
        return;
      }

      // Let the user pick the Pico's CDC device. (Optional: filter by VID 0x2e8a)
      port = await navigator.serial.requestPort(/* { filters: [{ usbVendorId: 0x2e8a }] } */);
      await port.open({ baudRate: 115200 });

      // Assert DTR/RTS to keep CDC up on MicroPython
      try { await port.setSignals({ dataTerminalReady: true, requestToSend: true }); } catch {}

      // Tiny settle
      await new Promise(r => setTimeout(r, 50));

      writer = port.writable.getWriter();
      reader = port.readable.getReader();
      readAbort = new AbortController();

      $("connect").disabled = true;
      $("disconnect").disabled = false;
      $("sendRaw").disabled = false;
      $("btnWrite").disabled = false;
      $("btnRead").disabled = false;
      $("status").textContent = "Connected";

      $("btnUpload").disabled = false;

      log("Connected.");

      readLoop();
    }

    async function readLoop() {
      const decoder = new TextDecoder();
      let buffer = "";

      try {
        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          if (!value) continue;

          buffer += decoder.decode(value, { stream: true });

          let idx;
          while ((idx = buffer.indexOf("\n")) !== -1) {
            const line = buffer.slice(0, idx).trim();
            buffer = buffer.slice(idx + 1);
            if (!line) continue;
            try {
              const obj = JSON.parse(line);
              handleIncoming(obj);

            } catch {
              log("<< non-JSON >> " + line);
            }
          }
        }
      } catch (e) {
        log("Read error: " + e.message);
      }
    }

    async function closePort() {
      $("status").textContent = "Closing…";
      try {
        if (reader) { try { await reader.cancel(); } catch {} try { reader.releaseLock(); } catch {} reader = null; }
        if (writer) { try { await writer.close(); } catch {} try { writer.releaseLock(); } catch {} writer = null; }
        try { await port.setSignals({ dataTerminalReady: false, requestToSend: false }); } catch {}
        if (port) { try { await port.close(); } catch {} port = null; }
      } finally {
        $("connect").disabled = false;
        $("disconnect").disabled = true;
        $("sendRaw").disabled = true;
        $("btnWrite").disabled = true;
        $("btnRead").disabled = true;

        $("btnUpload").disabled = true;

        $("status").textContent = "Not connected";
        log("Disconnected.");
      }
    }

    //let port, reader, writer; // (keep your originals)
    const waiting = new Map(); // for per-step ACK routing

    function awaitAck(key) {
      return new Promise((resolve, reject) => {
        waiting.set(key, resolve);
        setTimeout(() => {
          if (waiting.get(key)) {
            waiting.delete(key);
            reject(new Error("Timeout waiting for " + key));
          }
        }, 15000); // 15s step timeout
      });
    }

    function handleIncoming(obj) {
      // Route upload ACKs first
      if (obj && obj.ack) {
        const key =
          obj.ack === "file_begin" ? "file_begin" :
          obj.ack === "file_end"   ? "file_end"   :
          obj.ack === "file_chunk" ? `file_chunk:${obj.seq}` : null;
        if (key && waiting.has(key)) {
          const res = waiting.get(key);
          waiting.delete(key);
          res(obj);
          return;
        }
      }
      // Fall back to your normal logging
      log(obj);
    }


    async function sendJSON(obj) {
      if (!writer) return;
      const data = new TextEncoder().encode(JSON.stringify(obj) + "\n");
      await writer.write(data);
      log(">> " + JSON.stringify(obj));
    }

    async function uploadAndFlash() {
      const file = $("file").files?.[0];
      if (!file) { alert("Choose a file first."); return; }

      const chunkSize = Math.min(Math.max((+$("chunkSize").value)|0, 128), 8192);
      const verify = $("verifySha").checked;
      const autoFlash = $("autoFlash").checked;

      $("uStatus").textContent = "Hashing…";
      const buf = await file.arrayBuffer();
      const size = buf.byteLength;

      let shaHex = null;
      if (verify && crypto?.subtle?.digest) {
        const hash = await crypto.subtle.digest("SHA-256", buf);
        shaHex = [...new Uint8Array(hash)].map(b => b.toString(16).padStart(2, "0")).join("");
      }

      // Begin
      $("uStatus").textContent = "Starting upload…";
      await sendJSON({ op: "file_begin", name: file.name, size, sha256: shaHex, auto_flash: autoFlash });
      await awaitAck("file_begin");

      const u8 = new Uint8Array(buf);
      let sent = 0, seq = 0;
      $("prog").max = size; $("prog").value = 0;

      while (sent < size) {
        const n = Math.min(chunkSize, size - sent);
        const chunk = u8.subarray(sent, sent + n);
        // base64 encode (chunk size is clamped to keep this safe)
        const b64 = btoa(String.fromCharCode.apply(null, chunk));
        await sendJSON({ op: "file_chunk", seq, b64 });
        await awaitAck(`file_chunk:${seq}`);
        sent += n; seq++;
        $("prog").value = sent;
        $("uStatus").textContent = `Uploading… ${sent}/${size} bytes`;
      }

      await sendJSON({ op: "file_end" });
      const endAck = await awaitAck("file_end");

      $("uStatus").textContent = endAck?.ok ? (autoFlash ? "Uploaded; flashing…" : "Upload complete.") : "Upload finished with errors.";
    }

    
    // UI wiring
    $("connect").addEventListener("click", async () => {
      try { await openPort(); } catch (e) { log("Connect error: " + e.message); }
    });

    $("disconnect").addEventListener("click", async () => {
      try { await closePort(); } catch (e) { log("Close error: " + e.message); }
    });

    $("sendRaw").addEventListener("click", async () => {
      try {
        const obj = JSON.parse($("raw").value);
        await sendJSON(obj);
      } catch {
        alert("Invalid JSON.");
      }
    });

    $("btnWrite").addEventListener("click", async () => {
      const addr = (+$("addr").value)|0;
      const reg = (+$("reg").value)|0;
      const hex = $("dataHex").value.trim().split(/\s+/).filter(Boolean);
      const data = hex.map(h => parseInt(h, 16) & 0xFF);
      await sendJSON({ op: "i2c_write", addr, reg, data });
    });

    $("btnRead").addEventListener("click", async () => {
      const addr = (+$("addr").value)|0;
      const reg = (+$("reg").value)|0;
      const length = (+$("readLen").value)|0;
      await sendJSON({ op: "i2c_read", addr, reg, length });
    });

    $("clearLog").addEventListener("click", () => { $("log").value = ""; });
    window.addEventListener("beforeunload", async () => { try { await closePort(); } catch {} }); 

    $("btnUpload").addEventListener("click", async () => {
      try { await uploadAndFlash(); }
      catch (e) { $("uStatus").textContent = e.message; log("Upload error: " + e.message); }
    });




  </script>
</body>
</html>
